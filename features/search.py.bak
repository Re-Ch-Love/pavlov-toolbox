from typing import Dict, List
from PySide6 import QtNetwork
from PySide6.QtGui import QKeySequence
from qfluentwidgets import InfoBar, InfoBarPosition
import requests
import urllib.parse
from PySide6.QtWidgets import QApplication, QWidget, QTableWidgetItem, QHeaderView
from PySide6.QtCore import QThread, Signal, Qt
from ui.search_interface_ui import Ui_SearchInterface
from features.common import *


SEARCH_LIMIT = 10


class SearchThread(QThread):
    searchFinishSignal = Signal(list)
    searchErrorSignal = Signal(str)

    def __init__(self, input: str):
        super().__init__()
        self.input = input

    def run(self):
        try:
            res = requests.get(
                f"https://api.pavlov-toolbox.rech.asia/modio/v1/games/@pavlov/mods?_limit={SEARCH_LIMIT}&_sort=-popular&_q={urllib.parse.quote(self.input)}",
            )
        except requests.exceptions.ConnectionError:
            self.searchErrorSignal.emit("无法连接到服务器")
            return
        if res.status_code != 200:
            self.searchErrorSignal.emit("服务器发生错误")
            return
        data: List[Dict] = res.json()["data"]
        self.searchFinishSignal.emit([Mod(x) for x in data])


class SearchInterface(QWidget):
    def __init__(self):
        super().__init__()
        self.ui = Ui_SearchInterface()
        self.ui.setupUi(self)
        self.ui.searchLineEdit.searchSignal.connect(self.search)
        self.ui.searchLineEdit.searchButton.setShortcut(QKeySequence("Return"))
        self.is_searching = False
        self.naManager = QtNetwork.QNetworkAccessManager()
        header = self.ui.resultTableWidget.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
        header.setStretchLastSection(True)

    def search(self, input):
        if input.strip() == "":
            return

        if self.is_searching:
            return

        self.is_searching = True

        def onSearchError(reason: str):
            self.is_searching = False
            self.search_thread.quit()
            InfoBar.error(
                title="无法获取搜索结果",
                content=reason,
                position=InfoBarPosition.BOTTOM_RIGHT,
                duration=-1,
                parent=self,
            )

        def onSearchFinish(data: List[Mod]):
            if len(data) == 0:
                InfoBar.info(
                    title="搜索完毕",
                    content="没有找到相关的Mod",
                    position=InfoBarPosition.BOTTOM_RIGHT,
                    duration=3000,
                    parent=self,
                )
                return
            self.ui.resultTableWidget.setRowCount(len(data))

            def uneditableiItem(content: str):
                item = QTableWidgetItem(content)
                item.setFlags(item.flags() ^ Qt.ItemFlag.ItemIsEditable)
                return item

            for index, mod in enumerate(data):
                try:
                    downloadUrl = mod.getWindowsDownloadUrl()
                except TargetNotFound:
                    downloadUrl = "无法获取"
                self.ui.resultTableWidget.setItem(
                    index, 0, uneditableiItem(mod.getName())
                )
                self.ui.resultTableWidget.setItem(
                    index, 1, uneditableiItem(str(mod.getResourceId()))
                )
                self.ui.resultTableWidget.setItem(
                    index, 2, uneditableiItem(downloadUrl)
                )

        def onThreadFinished():
            self.is_searching = False
            self.search_thread.deleteLater()

        self.search_thread = SearchThread(input)
        self.search_thread.searchErrorSignal.connect(onSearchError)
        self.search_thread.searchFinishSignal.connect(onSearchFinish)
        self.search_thread.finished.connect(onThreadFinished)
        self.search_thread.start()


if __name__ == "__main__":
    app = QApplication()
    window = SearchInterface()
    window.show()
    app.exec()
